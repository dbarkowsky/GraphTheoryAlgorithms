Good for dense graphs. Always chooses the next best edge.
Faster than Kruskal's, but not good for parallel computation.

Cannot do disconnected graphs easily. It would have to be run on each connected component individually.

Runtime of O(E * log(E)) for the lazy version.

## Steps
1. Make priority queue, sorting edges based on min edge cost.
2. Start on any starting node. Mark as visited, and add edges to the queue.
3. While queue is not empty and full MST has not been found:
	1. Get next edge from queue. 
		1. If the "To" node of the edge has already been visited, skip it.
		2. Otherwise, mark as visited, add edge to the MST, then add new node's edges to queue. Don't add ones that point to visited nodes.

An adjacency list representation of this looks like a doubly-linked list, with directional edges going back and forth between each node pair. This is done for ease of the algorithm, even if the actual graph is undirected.

How do we know the tree is complete? 
The number of edges is 1 less than the number of nodes in the graph!

How to find the tree's cost?
Sum the weights of all the selected edges.