A data structure used for range queries on static arrays.

What's a range query? Usually operations like max, min, sum, gcd.
For example, I want to know the max value from indexes 4 to 10.

Every positive integer can be represented as a sum of powers of two (or as binary).
So, intervals, which are based on positive indexes in array, can also be broken down like that.

U = union
For example, [5, 17] = [5, 5 + 2^3]  U [13, 13 + 2^2] U [17, 17 + 2^0]
which also equals [5, 13] U [13, 17] U [17, 18]
These ranges are not inclusive of the second number, so you can see the last set of unions would still cover 5 to 17.

## Range Combinations
Functions need to be *associative* = the order of operations does not matter. 
Best case scenario, range queries are O(1), but only when overlap friendly.

For example, binary function f(x, y) is overlap friendly if:
f( f(a,b), f(b, c)) = f(a, f(b,c)) for all valid a,b,c

So, if we have three sums of ranges (16, 7, and 18) in an array, we can check:
where f (x,y) = x + y ..... getting the sum
f(f(16, 7), f(7, 18)) = f(23, 25) = 48.  BUT
f(16, f(7, 18)) = f(16, 25) = 41

These are not equal! so this isn't an associative function AKA not overlap friendly.
## What does Sparse Table do?
It actually computes all possible answers for intervals size of 2^N, where N is the size of the array. Round down if not a whole number.
## Building a Table
P = table rows
N = array size
So if we have an array size 13, then P = floor(log2(13)) = 3.
Need Nlog(N) memory space for this.

1. Create a 2D array with P + 1 rows and N columns.
2. Fill row 0 with the input array values.
3. Fill the cells. Each cell holds the answer for the range [j, j + 2^i]. 
	1. i is the row index, j is the column index
	2. So, if index [0, 5] (i, j) then the value calculated at [2, 5] is for the range [5, 9]. This is because [5, 5 + 2 ^ 2] or [5, 9].
	3. The actual value of the cell depends on the first row value and the function we're storing values for.

What about if the interval reaches outside the table?
Simply mark them as invalid and ignore them. We don't do partial ranges.

Each row can actually build off of the row above. So if we already know the values for row 1, then row 2 is simply the result of the row above. 
This saves a lot of time!

## Using the Table
This also means the final row has a much smaller number of items to check. For example, if we needed the minimum number, the last row may contain less than half the numbers from above. 
We don't even have to check each item in that row, just the first and last values needed to encompass the queried range in the original array.

So to find a min value from range [1, 11] :
1. Find length of interval requested. 
	1. len = right - left + 1  = 11 - 1 + 1 = 11
2. Find value of P, which was floor(log2(len)).
	1. So floor(log2(len)) = 3
3. Find the value of k
	1. k = 2^P = 8
4. So min value is min(valueAt(P, left), valueAt(P, right - k + 1))
	1. = min(valueAt(3, 1), valueAt(3, 4))
5. Answer depends on values of table (which depends on original array)

## Non-Overlap Friendly
Some functions aren't overlap friendly (looking at sums and some multiplication).
These have O(log2(n)) complexity instead of O(1).

We have to do a *cascading query* on the sparse table instead. We break it into smaller ranges of size 2^x which do not overlap.
For example, for a range of [2, 15], it is split into intervals lengths 8, 4, and 2.
So [2, 2 + 2^3] U [10, 10 + 2 ^2] U [14, 14 + 2^1]
Which = [2, 10] U [10, 14] U [14, 16]
Remember ends of ranges are not inclusive.