Similar to the lazy version ([[3. Prim's Minimum Spanning Tree (Lazy)]]), but instead of adding potentially stale (invalid) edges to the queue, it uses node:edge key:value pairs.

The key to this: For any MST with directed edges, each node must be paired with exactly one incoming edge, other than the start node, whose edge is always outgoing.

We have to determine which incoming edge for each node to select for the final MST.
Instead of adding edges to a queue, we will *relax* the destination node's best found edge.
## How?
Could use Indexed Priority Queue (IPQ). Like a mix of priority queue and hash table. 
Reduced time complexity to O(E * logV)

relaxing: updating the entry in the IPQ for the node (to). If the edge(to):edge(weight) is less than the previous value.

1. Maintain IPQ of size N (number of nodes).
	1. It should sort node:edge pairs based on (minimum) edge cost. Why minimum? Because it could have multiple incoming edges.
2. Select starting node, mark as visited, and *relax* all edges of this node.
3. While IPQ is not empty and MST is not fully formed: 
	1. Dequeue next best pair.
	2. Mark as visited.
	3. Add edge to MST.
	4. Relax all edges of V, but not any edge pointing to a node already visited.