This kind of search can also be used for grids.
- They are essentially graphs with defined edges.
BFS only works to find shortest path if unweighted

One option is to convert to adjacency list or matrix, but is not always optimal.

Instead, consider...
## Row Vectors
e.g.
If you have locations based on coordinates [0, 0], and you can only move in cardinal directions, then you just have four edge options: [-1, 0], [1, 0], [0, -1], [0, 1]

```python
row_directions = [-1, 1, 0, 0]
column_directions = [0, 0, -1, 1]
current = [0, 0]

for (i = 0; i < 4; i++):
	new_row = current[0] + row_directions[i]
	new_column = current[1] + column_directions[i]
	# skip out of bounds possibilities
	if new_row < 0 or new_column < 0: continue
	if new_row >= MAX_ROWS or new_column >= MAX_COLUMNS: continue
	
```

We store location as [x, y], which can be tougher to unpack.
This doesn't translate well if there are multiple dimensions to your graph. (not 2D)
## Alternative State Representation
- Use one queue for each dimension
	- So if three dimensions, you will have an x queue, a y queue, and a z queue
	- Must enqueue or dequeue all at the same time
 Personal Note: I find this worse than just storing more complex nodes.