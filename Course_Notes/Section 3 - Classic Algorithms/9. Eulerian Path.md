What is it?
A path of edges that visits all edges exactly once.

Considered an **Eulerian Circuit** if it starts and ends on the same node (vertex).
If there's not a circuit, it's possible that you can't do a full path. This affects how we tackle the problem.

Don't guess at this. It can be determined.

|                  | Eulerian Circuit                               | Eulerian Path                                                                                                                                                   |
| ---------------- | ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Undirected Graph | Every vertex has an even degree.               | Either every vertex has an even degree or exactly two vertices have odd degrees.                                                                                |
| Directed Graph   | Every vertex has equal indegree and outdegree. | At most one vertex has (outdegree - indegrees) = 1 and at most one vertex has (indegree - outdegree)  = 1 and all other vertices have equal in and out degrees. |
What is a degree?
If undirected graph, just how many edges are attached to node.
If directed graph, there's ins and outs. Indegrees enter node, outdegrees exit node.

Doesn't count as a eulerian path if the graph is completely separated in some way (subgraphs with no connecting edges), but single unconnected nodes are okay for some reason.

## The Algorithm
Find the path. If the path exists, you may just get the circuit for free if it exists.
Time complexity: O(e) where e = edges

1. Does a path even exist? Use the above checks to determine if a circuit or path even exist for starters.
	1. For each edge, look at the connecting nodes and log the ins/outs for that node. 
	2. After all edges have been checked, see if the logged ins/outs for nodes are valid with above table.
2. If we verify there is a path, where do we start?
	1. Look again at ins/outs. If all nodes have even degrees, start anywhere. Otherwise, you must start at the node that has more outs than ins (directed graph).
	2. The end node if there's no circuit, is the node with the additional indegree.
3. DFS, but forced to visit all edges before finding the end node.
	1. If you get stuck (no outgoing edges), backtrack. Add these backtracked nodes to the list representing the path.
	2. Once you backtrack to a node with unexplored edges, go that way instead. 
	3. The backtracking is just unwinding recursion.
	4. When you traverse an edge, decrease the count of outgoing edges from that node to help track which nodes have already been exhausted.
## Pseudocode
```
n = number of nodes
e = number of edges
graph = graph as adjacency list

ins = list counting indegress, index is node value
outs = same thing, but for outdegrees

path = list or other data structure. Something with variable length is good.

func countInsAndOuts()
	for edge in graph
		outs[edge.from]++
		ins[edge.to]++

func graphHasPath()
	startNodes = 0
	endNodes = 0
	for (i = 0; i < n; i++)
		if (outs[i] - ins[i]) > 1 or (ins[i] - outs[i]) > 1
			return false
		else if outs[i] - ins[i] == 1
			startNodes++
		else if ins[i] - outs[i] == 1
			endNodes++
	return  (endNodes == 0 and startNodes == 0) or
			(endNodes == 1 and startNodes == 1)

func findStartingNode()
	// assume 0 for start
	startNode = 0
	for (i = 0; i < n; i++)
		// If there's a node with more outs than ins, must be the start
		if outs[i] - ins[i] == 1 return i
		// If there are outs to this node at all, mark it as the new start
		if outs[i] > 0: startNode = i
	return startNode

func dfs(at)
	// While current node has outgoing edges
	while (outs[at] != 0)
		// Get next unvisited outgoing edge
		nextEdge = graph[at].get(--out[at]) // decrement and get
		dfs(nextEdge.to)
	// Backtrack, putting node at front of path so far
	path.unshift(at)

func findPath()
	countInsAndOuts()
	if !graphHasPath() return null

	startingNode = findStartingNode
	dfs(startingNode)

	// Check if there are disconnected graphs
	if path.length == e + 1 return path
	return null
```