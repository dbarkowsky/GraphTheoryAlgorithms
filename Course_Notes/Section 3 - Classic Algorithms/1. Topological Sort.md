- Used for real-world situations where some events must occur before others
	- Like class pre-requisites
- Determines which order nodes should occur in
	- Each directed edge defines order
- Can work in O(num_node + num_edge) time.
- Not every graph has valid ordering
	- Like when there's a cycle (closed loop)
	- Only Directed Acyclic Graphs (DAG) have this
	- But! All trees have an order, as they have no cycles and are all directed

## How to?
1. Find unvisited node
2. Do DFS to find other unvisited nodes
3. Recurse, adding current node to order

This ordering is not always the same for a tree depending on what nodes you visit in which order. 

Example assuming graph is an adjacency list:
```python
function topsort(graph):
	N = len(graph)
	V = [false, ..., false] # length N
	ordering = [0, ..., 0] # length N
	i = N - 1 # index for ordering array

	for (at = 0; at < N; at += 1):
		if V[at] == false:
			i = dfs(i, at, V, ordering, graph)
	return ordering

function dfs(i, at, V, ordering, graph):
	V[at] = true
	edges = graph.getEdgesFromNode(at)
	for edge in edges:
		if V[edge.to] == false:
			dfs(i, edge.to, V, ordering, graph)
	ordering[i] = at
	return i - 1
```

