- Single source algorithm -> need to specify starting node
- Only for non-negative weights
	- Otherwise it's difficult to know if the cost can be improved. "Greedy"
- Time complexity O(edges * log(nodes))

High-level process:
1. Array for distances. Corresponds to index of each node and indicates distance from start.
	1. Initialize with infinity
2. Priority queue of node-index pairs. 
	1. Tells which node to visit next (start of queue)
3. Insert (start, 0) to queue.
4. Loop while queue isn't empty
	1. Get next (node, distance) pair
	2. Get edges from that node
	3. Add (node, distance) pair to queue for each edge

If a node still has distance infinity at the end, it is unreachable

How do we know the actual shortest path?
- Track the previous array for each node. Save the node with the best cost so far. 
- After, start at the ending node and work your way backwards using these previous node records.

Do we have to visit every node, or can we stop early?
- Depends on the graph, but if you are currently visiting a node, then it's presumed that other paths must be longer, so we've already taken the shortest path.
- Can "eject" at that point and work backwards from there. 
- It's assumed shortest because of the priority queue
## Lazy Implementation
What is "lazy"?
- The priority queue has duplicate keys.
	- We only delete those duplicates when we get to them and see that their cost is already worse than the current cost we know to get to this node.
- Not ideal for space, but faster than trying to search and remove from the queue on bigger scales.
- Inefficient for dense graphs
	- So many pairs will be added to the queue, but it's not worth visiting all of them

## Eager Implementation
What is "eager"?
- We do not store duplicate keys in the queue
	- This is better done with an Indexed Priority Queue
	- Only takes as much space as there are nodes.
- Algo difference from Lazy
	- Instead of always adding a new item to the queue, overwrite existing values if they exist and have worse cost than current path
- Priority queue could be done with a Map... 
	- Would be constant lookup and update time

## Heap Optimization
- Using a D-ary heap
	- Each node has D children
	- Very useful for dense graphs
	- Not good with removals, but there aren't as many removals in Dijkstra's
- The D should equal (edges / nodes)
- Fibonacci heap is even better... but hard to implement
	- for large graphs