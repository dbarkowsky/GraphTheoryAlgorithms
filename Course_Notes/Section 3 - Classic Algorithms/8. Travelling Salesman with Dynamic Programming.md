Given a list of cities (nodes) and distances between cities (weighted edges), what's the shortest possible route to visit all cities exactly once and return to the starting city?

NOTE: If a path between nodes does not exist, use the value of Infinity to keep it as the least-optimal route. This assumes there is some other path to use.

Very difficult for large inputs.

## Brute Force Way
Calculate each possible combination of routes. 
O(n!) time complexity, which means it gets really bad when you have a lot of nodes.
Not recommended.

## Dynamic Programming Way
O(n^2 * 2^n) -> which is actually worse for smaller graphs.
But for large graphs it's much better.
What is "large" though?

| n   | n!            | n^2 * 2^n |
| --- | ------------- | --------- |
| 1   | 1             | 2         |
| 5   | 120           | 800       |
| 15  | 1307674368000 | 7372800   |
Somewhere between 5 and 15 then. Best to stick with DP way.

First Goal: Determine sub paths of getting from A -> B. We can reuse this information to speed up the results as we go.
!! Starting node must have an index in this range: 0 <= starting node < total number of nodes !!

1. Select starting node.
2. Store best value from S to every other node.
	1. When dealing with paths that involve multiple nodes, we need to know the visited nodes along the subpath and the index of the last visited node.
	2. Together, these form the state of the crawl. There are N possible nodes that we could have visited last and 2^n possible subsets of visited nodes.
	3. This makes the space complexity O(n * 2^n)

It is suggested that you store the visited node information as a 32-bit integer due to its compactness and easy caching.
e.g. If we have nodes 0-4, and nodes 0 and 2 are visited, we'd use the int 0101. 
- We count from the right here. So 0 and 2 index are marked as true (1)
This means the end state (we've visited everything) is when all bits are 1.


