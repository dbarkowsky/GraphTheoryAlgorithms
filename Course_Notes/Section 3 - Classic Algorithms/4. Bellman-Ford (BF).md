Finds the shortest path from start to any other node.
- Not ideal for most path searches, because it has high time complexity. O(EV)
- Usually use Dijkstra

When do we use this?
- When a graph has negative edge weights. 
	- In this case, Dijkstra's fails (loops)
- It can detect negative cycles. 
	- Useful in financial situations (buying/selling)

Negative Cycles
- Could be because negative self loops, when a node has edge back to itself with a negative weight
- Often just because a negative value keeps making that direction more appealing for algorithm, but then it never escapes that loop
- Cost of path will always appear as -Infinity in this case

BF Steps
- E = number of edges
- V = number of vertices (nodes)
- S = id of staring nodes
- D = array of size V. Tracks the best distance from S to each node

1. Set each entry in D to Infinity
2. Set D[S] to 0
3. Relax each edge V-1 times
	1. This means to check if there's a better cost already found for the "to" side of the edge.
	2. e.g. if the distance to edge.from + edge.cost < the distance to edge.to, then update the distance of edge.to (in this case D[edge.to]) to this smaller value (D[edge.from] + edge.cost)
4. To find negative cycles, check the edges again. 
	1. If the cost of the edge.from + edge.cost is still less than edge.to cost, then we have a negative cycle. It just keeps getting lower when it should be the same!
	2. Mark this cost as negative Infinity
	3. This marks node both IN the negative cycle and those affected by the cycle


